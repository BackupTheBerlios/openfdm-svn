* Rigid body should again do something.
  - Have multiple coordinate systems defined in the rigid body.
  - Reuse them across links to that rigid body.
  - This will avoid recomputations of these local coordinate systems for
  - multiple models acting at the identical position offset ...
  - by default, just use the parent coordinate system ...


Class Hierarchy for the Contexts and the associated Nodes:

MechanicContext
 |- JointContext (has a unique parent and child link)
 |- SingleLinkInteractContext (has a single parent link)
 |- DoubleLinkInteractContext (has two parent links, constraint
 |       joints need to implement that in the future)
 |- RigidBodyContext (has a unique parent and may be a list of links with
         different local coordinate systems, see above)

* More init time checking for SimpleDirectModels
* Template Contexts for SimpleDirectModels
* Sensor
* Move Mechanics into a normal ModelContext??
* Remove LeafNode??
* Environmental cache ...
  - May be put that into the Task???
  - May be an extra argument to the mechanical system functions?
  - May be have a 'RootLink' pointer/id in each MechanicLinkValue, and have
    an environment cache for each RootLink (std::map<RootLinkId, Cache>)??
* Single link MechanicContext has a local coordinate system
* Optimize inertia transforms.
* Give Mass an own Context with a pretransformed Inertia

* Check why harmonic is so bad ...
* Clean up SampleTime/Fraction

* Connect api in Group is questionable
* Tests for error checks in Connect and System initialization

* Enable ports, ContextGroups??
* Nodes duerfen nur zu einem System gehören
* test dazu
* State allocation überarbeiten
* Library models und parents
* lock on exec
* Zap Variant. Use TypeInfo data for that reason
* PortInfo::isContinous()
* System externe PortValues

* Improove TransferFunction
* Test TrasnferFunction!!

* AeroForces handling of alphadot/betadot.

* Improove the WGS84 gravity
* Add link property to tell if we already have the gravity applied at the
  root link or if this should be applied in the mass models.
* Test Gravity ...

* Function -> AbstractFunction
* LLVM - compile optimized c code from a model??

* PortInfo -> Port ??? PortInfo ist dann System init time Datum fuer
  port typ und size??? Dann kann AbstractModel die typen und sizes checken
  bevor PortValues alloziert werden und Typ angepasste Kontexte gebaut werden???

